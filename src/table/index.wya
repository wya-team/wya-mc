<template>
	<scroll-view 
		id="{{ tableId }}"
		scroll-x="{{ scrollX }}" 
		scroll-left="{{ scrollLeft }}"
		style="{{ mcStyle }}"  
		class="mc-table mc-class"
		bindscroll="handleScroll"
	>
		<!-- 表格头 start -->
		<mc-table-header 
			wx:if="{{ doLayouted }}"
			header-class="header-class"
			border="{{ border }}"
			columns="{{ columns }}"
			defaultSort="{{ defaultSort }}"
			scrollWidthStyle="{{ scrollWidthStyle }}"
			tHeadStyle="{{ tHeadStyle }}"
			tHeadTrStyle="{{ tHeadTrStyle }}"
			bind:header-click="handleHeaderClick"
		/>
		<!-- 表格头 end -->

		<!-- 表格体 start -->
		<mc-table-body 
			wx:if="{{ doLayouted }}"
			row-class="row-class"
			cell-class="cell-class"
			dataSource="{{ rebuildData }}"
			border="{{ border }}"
			stripe="{{ stripe }}"
			columns="{{ columns }}"
			scrollWidthStyle="{{ scrollWidthStyle }}"
			tBodyTrStyle="{{ tBodyTrStyle }}"
			tBodyTdStyle="{{ tBodyTdStyle }}"
			bind:row-click="handleRowClick"
		/>
		<!-- 表格体 end -->
	</scroll-view>
	<!-- 列表无数据处理 -->
	<view class="mc-table__empty" wx:if="{{ dataSource.length === 0 }}">
		<slot wx:if="{{ useEmptySlot }}" name="empty" />
		<view wx:elif="{{ empty }}">{{ empty }}</view>
	</view>
</template>
<script>
import McComponent from '../common/component';
import { getUid } from '../common/utils';

McComponent({
	externalClasses: ['header-class', 'row-class', 'cell-class'], 
	relations: {
		'./table-column': {
			type: 'descendant',
			linked(child) {
				this.children = this.children || [];
				this.children.push(child);

				const { columns } = this.data;
				columns.push(child.data);
				this.setData({ columns });
				this.refreshLayout();
				this.rebuildWidthRender();
			},
			unlinked(child) {
				const index = this.children.findIndex(i => i === child);

				if (index === -1) return;
				this.children.splice(index, 1);

				const { columns } = this.data;
				columns.splice(index, 1);

				this.setData({ columns });
				this.refreshLayout();
				this.rebuildWidthRender();
			}
		}
	},
	props: {
		dataSource: {
			type: Array,
			value: [],
			observer() {
				this.rebuildData();
				this.rebuildWidthRender();
			}
		},
		// table的高度, 溢出可滚动
		height: { 
			type: String,
			value: 'auto'
		},
		width: {
			type: [Number, String],
			value: '100%'
		},
		// 是否带有纵向边框
		stripe: {
			type: Boolean,
			value: false
		},
		// 是否带有纵向边框
		border: {
			type: Boolean,
			value: false
		},
		empty: {
			type: String,
			value: '暂无数据~'
		},
		defaultSort: {
			type: Object,
			value: {
				prop: '',
				order: ''
			}
		},
		tHeadStyle: {
			type: String,
			value: ''
		},
		tHeadTrStyle: {
			type: String,
			value: ''
		},
		tBodyTrStyle: {
			type: String,
			value: ''
		},
		tBodyTdStyle: {
			type: String,
			value: ''
		},
		useEmptySlot: {
			type: Boolean,
			value: false
		}
	},
	data: {
		tableId: '',
		containerWidth: 0,
		scrollX: false,
		scrollLeft: 0,
		scrollWidthStyle: 'width: auto',
		doLayouted: false,
		columns: [],
		rebuildData: []
	},
	lifetimes: {
		ready() {
			this.setData({
				tableId: getUid('table'),
			});

			this.$emit('ready', this);
		},
		attached() {
			this.createSelectorQuery()
				.select(`#${this.data.tableId}`)
				.boundingClientRect((res) => {
					const width = (res && res.width) || wx.getSystemInfoSync().windowWidth;
					this.setData({
						containerWidth: width,
						scrollWidthStyle: `width: ${width}px;`
					});
					this.refreshLayout();
				})
				.exec();
		}
	},
	methods: {
		handleRowClick(e) {
			this.triggerEvent('row-click', e.detail);
		},

		handleHeaderClick(e) {
			const { prop, order } = e.detail;

			// TODO: 内部提取，修改了父层
			this.setData({
				defaultSort: {
					prop,
					order
				}
			});

			this.triggerEvent('sort-change', { prop, order });
		},

		handleScroll(e) {
			this.setData({
				scrollLeft: e.detail.scrollLeft
			});
		},

		refreshColumn(child, k, v) {
			const index = this.children.findIndex(i => i === child);

			if (index === -1) return;

			this.setData({
				[`columns[${index}].${k}`]: v
			});

			this.refreshLayout();
			this.rebuildWidthRender();
		},

		refreshLayout() {
			if (!this.data.containerWidth) return;
			const width = this.data.columns.reduce((pre, cur) => {
				 pre += cur.width;
				 return pre;
			}, 0);

			if (width > this.data.containerWidth) {
				this.setData({
					scrollX: true,
					scrollWidthStyle: `width: ${width}px;`
				});
			} else {
				let levelWidth = this.data.containerWidth - width;
				this.data.columns.forEach((item, index) => {
					this.setData({
						[`columns[${index}].realWidth`]: (item.width) + levelWidth * (item.width / this.data.containerWidth) 
					});
				});
			}

			this.setData({
				doLayouted: true
			});
		},

		rebuildData() {
			const { dataSource } = this.data;
			this.setData({
				rebuildData: dataSource
			});
		},

		rebuildWidthRender() {
			const { columns, rebuildData } = this.data;
			if (!columns.some(i => (typeof i.renderCell == 'function' || typeof i.renderHeader == 'function'))) return;

			const states = {};
			rebuildData.forEach((row, rowIndex) => {
				rebuildData[rowIndex]._renders = {
					cell: {},
					header: {}
				};
				columns.forEach((column, columnIndex) => {
					if (typeof column.renderCell === 'function') {
						states[`rebuildData[${rowIndex}]._renders.cell[${columnIndex}]`] = column.renderCell({
							row,
							column,
							rowIndex,
							columnIndex
						}) || '';
					}
				});
			});

			this.setData(states);
		}
	}
});

</script>
<style lang="scss">
@import '../common/index.scss';

.mc-table {
	position: relative;
	font-size: 28rpx;
	background: #fff;  
	width: 100%; 

	&__empty {
		display: flex;
		flex-direction: column;
		padding: 50rpx;
		background: #fff;  
		color: #666;
		justify-content: center;
		align-items: center;
	}
}

</style>
<config>
{
	"component": true,
	"usingComponents": {
		"mc-icon": "../icon/index",
		"mc-table-header": "./table-header",
		"mc-table-body": "./table-body"
	}
}
</config>
