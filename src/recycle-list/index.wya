<template>
	<movable-area class="mc-recycle-list mc-class" style="height: {{ height }}">
		<movable-view 
			class="mc-recycle-list__scroll"
			style="height: calc(100% + {{ refreshHeight }}rpx);"
			direction="vertical"
			y="{{ y }}"
			bind:change="handleMoveChange"
			bind:touchend="handleTouchEnd"
		>
			<scroll-view
				class="mc-recycle-list__view"
				scroll-y="{{ true }}"
				scroll-top='{{ scrollTop }}' 
				lower-threshold="{{ lowerThreshold }}"
				enable-back-to-top="{{ true }}"
				bind:scroll="handleScroll"
				bind:scrolltolower="handleEndReached"
			>
				<view 
					id="mc-refresh-view"
					class="mc-recycle-list__pull-down pull-down-class" 
					style="height: {{ refreshHeight }}rpx;"
				>
					<text class="mc-recycle-list__text">{{ PULL_DOWN_STATUS[pullDownStatus] }}</text>
				</view>

				<slot />

				<view class="mc-recycle-list__pull-up pull-up-class">
					<text class="mc-recycle-list__text"> {{ SCROLL_STATUS[scrollStatus] }}</text>
				</view>
				<block wx:if="{{ scrollStatus !== 0 && scrollStatus !== 1 }}">
					<slot name="extra" />
				</block>
			</scroll-view>
		</movable-view>
	</movable-area>
</template>
<script>
import McComponent from '../common/component';
import { PULL_DOWN_STATUS, PULL_UP_STATUS, SCROLL_STATUS } from './constant';

McComponent({
	externalClasses: ['pull-down-class', 'pull-up-class'],
	props: {
		pauseY: {
			type: Number,
			value: -10
		},
		height: {
			type: String,
			value: '100vh'
		},
		refreshHeight: {
			type: Number,
			value: 120,

		},
		total: {
			type: Number,
			value: 0,
			observer(value) {
				/**
				 * 特别声明(项目中)：连续两次total: 0, 就无法触发loadData
				 * 1. 与后端约定分页的接口数据为空时，要求后端total也要确保为1（总页数）;
				 * 
				 * 必要时候进行转换（1的情况，错误情况等）
				 * {
				 * 	status: 1,
				 * 	data: {
				 * 		list: [],
				 * 		page: { count: 0, current: 1, total: 1 }
				 * 	}
				 * }
				 */
				if (value === 0) {
					this.setData({
						currentPage: 0,
						scrollStatus: 0
					});
					this.loadDataForScroll({ force: true });
				}
			}
		},
		scroll: {
			type: Boolean,
			value: true
		},
		pull: {
			type: Boolean,
			value: true
		},
		show: {
			type: Boolean,
			value: true
		},
		scrollTop: { // 内部滚动距离
			type: Number,
			value: 0
		},
		listenSrcoll: { // 是否抛出滚动事件
			type: Boolean,
			value: false
		},
		lowerThreshold: {
			type: Number,
			value: 100
		}
	},
	data: {
		y: -60,
		refreshOffset: 0, // 下拉刷新视图高度
		isInited: false,
		/**
		 * 0.未touchstart 
		 * 1.pulling但未达到pauseY 
		 * 2.pulling达到pauseY 
		 * 3.进入pause状态 （loading）
		 */
		pullDownStatus: 0,
		PULL_DOWN_STATUS,
		/**
		 * 0: '上滑加载', 
		 * 1: '加载中', 
		 * 2: '已全部加载', 
		 * 3: '网络不稳定，请稍后重试', 
		 * 4: '没有内容可供显示'
		 */
		scrollStatus: 0,
		SCROLL_STATUS,
		/**
		 * 0.未touchstart 
		 * 1.pulling但未达到pauseY 
		 * 2.pulling达到pauseY 
		 * 3.进入pause状态 （loading）
		 */
		currentScrollTop: 0,
		// 页面
		currentPage: 0,
		animate: {}
	},
	lifetimes: {
		ready() {
			this.isReady = true;
			this.init();
			if (this.data.currentPage === 0) {
				this.loadDataForScroll();
			}
		},
		detached() {
			
		},
	},
	observers: {
		'show': function (show) {
			if (show) this.init();
			if (this.data.currentPage === 0) {
				wx.nextTick(() => {
					this.loadDataForScroll();
				});
			}
		},
		'refreshHeight': function (refreshHeight) {
			setTimeout(() => this.init(true), 10);
		}
	},
	methods: {
		/**
		 * 初始化scroll组件参数, 动态获取 下拉刷新区域
		 */
		init(force) {
			if (!this.isReady || !this.data.show || (this.data.isInited && !force)) return;
			this.createSelectorQuery().select("#mc-refresh-view").boundingClientRect((res) => {
				const height = -res.height;
				this.setData({
					refreshOffset: height,
					y: height,
					isInited: height > 0
				});
			}).exec();
		},
		handleMoveChange(e) {
			const { pullDownStatus, scrollStatus, pauseY } = this.data;
			let diff = e.detail.y;
			if (pullDownStatus >= 3 || scrollStatus == 1) return;
			if (diff > pauseY) {
				this.setData({ pullDownStatus: 2 });
			} else {
				this.setData({ pullDownStatus: 1 });
			}
		},
		handleTouchEnd() {
			const { pullDownStatus, refreshOffset } = this.data;
			if (pullDownStatus >= 3) return;
			if (pullDownStatus === 2) {
				wx.vibrateShort();
				this.setData({
					pullDownStatus: 3,
					y: 0,
				});
				this.handleRefresh();
			} else if (pullDownStatus === 1) {
				this.setData({ y: refreshOffset });
			}
		},
		handleEndReached() {
			this.loadDataForScroll();
		},
		handleRefresh() {
			this.$emit('loadData', { 
				page: 1, 
				refresh: true, 
				done: () => {
					let scrollStatus = this.data.total <= 1 ? 2 : 0;
					this.setData({
						pullDownStatus: 0,
						scrollStatus,
						y: this.data.refreshOffset,
						currentPage: 1
					});
				}
			});
		},
		loadDataForScroll(opts = {}) {
			const { force = false } = opts;
			if (!this.data.show || !this.data.scroll) return;
			if ((!force && this.data.scrollStatus >= 1)) return;
			this.setData({ scrollStatus: 1 });

			let page = force ? 1 : this.data.currentPage + 1;
			this.$emit('loadData', {
				page,
				done: () => {
					let scrollStatus = this.data.total <= page ? 2 : 0;
					this.setData({
						scrollStatus,
						currentPage: page
					});
				}
			});
		},
		handleScroll(e) {
			const scrollTop = e.detail.scrollTop;
			if (this.data.listenSrcoll) {
				this.$emit('scroll', scrollTop);
			}
		},
	}
});
</script>
<style lang="scss">
.mc-recycle-list {
	width: 100%;
	height: 100vh;
	overflow: hidden;
	.mc-recycle-list__scroll {
		width: 100%;
	}
	.mc-recycle-list__view {
		height: 100%;
		position: relative;
		box-sizing: border-box;
	}
	.mc-recycle-list__pull-down {
		font-size: 12rpx;
		display: flex;
		align-items: center;
		justify-content: center;
		overflow: hidden;
		.mc-recycle-list__text {
			color: #333;
			line-height: 60rpx;
			font-size: 24rpx;
		}
	}
	.mc-recycle-list__pull-up {
		display: flex;
		align-items: center;
		justify-content: center;
		height: 60rpx;
		.mc-recycle-list__text {
			color: #333;
			line-height: 60rpx;
			font-size: 24rpx;
		}
	}
}
</style>
<config>
{
	"component": true
}
</config>
